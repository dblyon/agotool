[uwsgi]
master-fifo = ago_UP_master.fifo

;; attach to zerg
socket = app.sock
zerg = zerg.sock
zerg-fallback = true

master = true ; false makes sense for debugging with e.g. Valgrind
strict = true ; Fail if unknown config parameter found
enable-threads = false ; Python threads not allowed (don't need them)
vacuum = false ; delete sockets during shutdown. Cleanup after yourself
single-interpreter = true ; single python interpreter per worker instance
die-on-term = true ; Shutdown when receiving SIGTERM
need-app = true ; Fail to start if application cannot load
lazy-apps = false ; loads your application one time per worker. thereby forking is disabled. false in zerg mode, but true with chain-reloading!

;; aGOtool settings
wsgi-file = runserver.py
callable = app
stats = stats.sock
memory-report = true
;; Aquarius /etc/nginx/sites-enabled/agotool.org.conf
auto-procname = true ; give processes names (master and worker)
;; prepend a useful name to the processes (can be seen in htop, but top doesn't show it)
procname-prefix = ago_UP_vassal_

;; Logging
; disable-logging = true ; uWSGI logging is too verbose
; log-4xx = true ; but we want to see critical errors
; log-5xx = true ; but we want to see critical errors
;; on if not debug
; req-logger = log_uwsgi_requests.log
;; on if not debug
; logger = file:log_uwsgi_error.txt
; To log to files instead of stdout/stderr and to simultaneously daemonize uWSGI.
daemonize = log_vassal.log
safe-pidfile = pid_vassal.pid

;; Buffer size
buffer-size = 32768

;; When to restart workers
max-requests = 80000 ; Restart workers after this many requests (STRING_v11: 80000)
; max-requests-delta = 5000 ; add (worker_id * delta) to the max_requests value of each worker --> for whatever reason setting not recognized
max-worker-lifetime = 604800 ; Restart workers after this many seconds (604800 --> 24*7*60*60, once per week).